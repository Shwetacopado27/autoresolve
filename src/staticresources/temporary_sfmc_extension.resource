{
  "recordTypeMap": {},
  "RecordSetBundles": [
    {
      "Records": [
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0t7Q000008XevDQAS"
          },
          "Id": "a0t7Q000008XevDQAS",
          "Name": "sfmc_Commit",
          "copado__ApiName__c": "sfmc_Commit_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1
        },
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0t7Q000008XevIQAS"
          },
          "Id": "a0t7Q000008XevIQAS",
          "Name": "sfmc_Deploy",
          "copado__ApiName__c": "sfmc_Deploy_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1
        },
        {
          "attributes": {
            "type": "copado__JobTemplate__c",
            "url": "/services/data/v57.0/sobjects/copado__JobTemplate__c/a0t7Q000008XevNQAS"
          },
          "Id": "a0t7Q000008XevNQAS",
          "Name": "sfmc_Retrieve",
          "copado__ApiName__c": "sfmc_Retrieve_1",
          "copado__Type__c": "Custom",
          "copado__Version__c": 1
        }
      ],
      "ObjectType": "copado__JobTemplate__c"
    },
    {
      "Records": [
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0s7Q000000vRBQQA2"
          },
          "Id": "a0s7Q000000vRBQQA2",
          "Name": "Step 1",
          "copado__ApiName__c": "sfmc_Commit_1_Step 1_0",
          "copado__ConfigJson__c": "{\"functionName\":\"sfmc_Commit\",\"parameters\":[{\"required\":true,\"name\":\"commit_message\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.message}\"},{\"required\":true,\"name\":\"credentialNameSource\",\"defaultValue\":\"{$Source.Property.credential_name}\"},{\"required\":true,\"name\":\"credentials\",\"defaultValue\":\"{$Pipeline.Property.mc_credentials}\"},{\"required\":true,\"name\":\"feature_branch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.featureBranchName}\"},{\"required\":true,\"name\":\"git_json\",\"defaultValue\":\"{$Context.Repository.Credential}\"},{\"required\":true,\"name\":\"main_branch\",\"defaultValue\":\"{$Pipeline.Main_Branch__c}\"},{\"required\":true,\"name\":\"metadata_file\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"required\":true,\"name\":\"recreateFeatureBranch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"},{\"required\":true,\"name\":\"source_mid\",\"defaultValue\":\"{$Source.Property.mid}\"},{\"required\":false,\"name\":\"debug\",\"defaultValue\":\"{$Pipeline.Property.debug}\"},{\"required\":false,\"name\":\"installMcdevLocally\",\"defaultValue\":\"{$Pipeline.Property.installMcdevLocally}\"},{\"required\":false,\"name\":\"mcdev_version\",\"defaultValue\":\"{$Pipeline.Property.mc_devtools_version}\"}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a0t7Q000008XevDQAS",
          "copado__Order__c": 0,
          "copado__Parent_Owner_Id__c": "0057Q000000MfOQ",
          "copado__Type__c": "Function"
        },
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0s7Q000000vRBVQA2"
          },
          "Id": "a0s7Q000000vRBVQA2",
          "Name": "Step 1",
          "copado__ApiName__c": "sfmc_Deploy_1_Step 1_0",
          "copado__ConfigJson__c": "{\"functionName\":\"sfmc_Deploy\",\"parameters\":[{\"required\":true,\"name\":\"credentialNameSource\",\"defaultValue\":\"{$Source.Property.credential_name}\"},{\"required\":true,\"name\":\"credentialNameTarget\",\"defaultValue\":\"{$Destination.Property.credential_name}\"},{\"required\":true,\"name\":\"credentials\",\"defaultValue\":\"{$Pipeline.Property.mc_credentials}\"},{\"required\":true,\"name\":\"git_json\",\"defaultValue\":\"{$Context.Repository.Credential}\"},{\"required\":true,\"name\":\"main_branch\",\"defaultValue\":\"{$Pipeline.copado__Main_Branch__c}\"},{\"required\":true,\"name\":\"merge_strategy\",\"defaultValue\":\"theirs\"},{\"required\":true,\"name\":\"metadata_file\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"required\":true,\"name\":\"promotionBranch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\"},{\"required\":true,\"name\":\"promotionName\",\"defaultValue\":\"{$Context.JobExecution__r.Deployment__r.Promotion__r.Name}\"},{\"required\":true,\"name\":\"source_mid\",\"defaultValue\":\"{$Source.Property.mid}\"},{\"required\":true,\"name\":\"sourceProperties\",\"defaultValue\":\"{$Context.apex.mcdo_GetPropertiesOfUSsInPromotion}\"},{\"required\":true,\"name\":\"target_mid\",\"defaultValue\":\"{$Destination.Property.mid}\"},{\"required\":true,\"name\":\"debug\",\"defaultValue\":\"{$Pipeline.Property.debug}\"},{\"required\":true,\"name\":\"deployNTimes\",\"defaultValue\":\"{$Pipeline.Property.deployNTimes}\"},{\"required\":true,\"name\":\"envVariablesDestination\",\"defaultValue\":\"{$Destination.apex.EnvironmentVariables}\"},{\"required\":true,\"name\":\"envVariablesDestinationChildren\",\"defaultValue\":\"{$Destination.apex.mcdo_ChildEnvironmentVariables}\"},{\"required\":true,\"name\":\"envVariablesSource\",\"defaultValue\":\"{$Context.apex.mcdo_SourceEnvironmentVariables}\"},{\"required\":true,\"name\":\"envVariablesSourceChildren\",\"defaultValue\":\"{$Context.apex.mcdo_SourceChildEnvironmentVariables}\"},{\"required\":true,\"name\":\"installMcdevLocally\",\"defaultValue\":\"{$Pipeline.Property.installMcdevLocally}\"},{\"required\":true,\"name\":\"mcdev_version\",\"defaultValue\":\"{$Pipeline.Property.mc_devtools_version}\"},{\"required\":true,\"name\":\"toBranch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\"}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a0t7Q000008XevIQAS",
          "copado__Order__c": 0,
          "copado__Parent_Owner_Id__c": "0057Q000000MfOQ",
          "copado__Type__c": "Function"
        },
        {
          "attributes": {
            "type": "copado__JobStep__c",
            "url": "/services/data/v57.0/sobjects/copado__JobStep__c/a0s7Q000000vRBaQAM"
          },
          "Id": "a0s7Q000000vRBaQAM",
          "Name": "Step 1",
          "copado__ApiName__c": "sfmc_Retrieve_1_Step 1_0",
          "copado__ConfigJson__c": "{\"functionName\":\"sfmc_Retrieve\",\"parameters\":[{\"required\":true,\"name\":\"credentialNameSource\",\"defaultValue\":\"{$Source.Property.credential_name}\"},{\"required\":true,\"name\":\"credentials\",\"defaultValue\":\"{$Pipeline.Property.mc_credentials}\"},{\"required\":true,\"name\":\"git_json\",\"defaultValue\":\"{$Context.Repository.Credential}\"},{\"required\":true,\"name\":\"main_branch\",\"defaultValue\":\"{$Pipeline.copado__Main_Branch__c}\"},{\"required\":true,\"name\":\"source_mid\",\"defaultValue\":\"{$Source.Property.mid}\"},{\"required\":true,\"name\":\"source_sfid\",\"defaultValue\":\"{$Source.Id}\"},{\"required\":true,\"name\":\"debug\",\"defaultValue\":\"{$Pipeline.Property.debug}\"},{\"required\":true,\"name\":\"installMcdevLocally\",\"defaultValue\":\"{$Pipeline.Property.installMcdevLocally}\"},{\"required\":true,\"name\":\"mcdev_version\",\"defaultValue\":\"{$Pipeline.Property.mc_devtools_version}\"}]}",
          "copado__CustomType__c": "Function",
          "copado__JobTemplate__c": "a0t7Q000008XevNQAS",
          "copado__Order__c": 0,
          "copado__Parent_Owner_Id__c": "0057Q000000MfOQ",
          "copado__Type__c": "Function"
        }
      ],
      "ObjectType": "copado__JobStep__c"
    },
    {
      "Records": [
        {
          "attributes": {
            "type": "copado__Function__c",
            "url": "/services/data/v57.0/sobjects/copado__Function__c/a0k7Q000000nwHCQAY"
          },
          "Id": "a0k7Q000000nwHCQAY",
          "Name": "sfmc_Commit",
          "copado__API_Name__c": "sfmc_Commit",
          "copado__Image_Name__c": "0onz6fxsbyolcopmojdzlxa5vzgsts-sfmc-devtools:v1.0",
          "copado__Options__c": "[]",
          "copado__Parameters__c": "[{\"required\":true,\"name\":\"commit_message\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.message}\"},{\"required\":true,\"name\":\"credentialNameSource\",\"defaultValue\":\"{$Source.Property.credential_name}\"},{\"required\":true,\"name\":\"credentials\",\"defaultValue\":\"{$Pipeline.Property.mc_credentials}\"},{\"required\":true,\"name\":\"feature_branch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.featureBranchName}\"},{\"required\":true,\"name\":\"git_json\",\"defaultValue\":\"{$Context.Repository.Credential}\"},{\"required\":true,\"name\":\"main_branch\",\"defaultValue\":\"{$Pipeline.Main_Branch__c}\"},{\"required\":true,\"name\":\"metadata_file\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"required\":true,\"name\":\"recreateFeatureBranch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.recreateFeatureBranch}\"},{\"required\":true,\"name\":\"source_mid\",\"defaultValue\":\"{$Source.Property.mid}\"},{\"required\":false,\"name\":\"debug\",\"defaultValue\":\"{$Pipeline.Property.debug}\"},{\"required\":false,\"name\":\"installMcdevLocally\",\"defaultValue\":\"{$Pipeline.Property.installMcdevLocally}\"},{\"required\":false,\"name\":\"mcdev_version\",\"defaultValue\":\"{$Pipeline.Property.mc_devtools_version}\"}]",
          "copado__Script__c": "#!/usr/bin/env node\n#!/usr/bin/env node\n\n/*\n * mcdev-copado v1.3.0 (built 2022-12-05T15:06:59.839Z)\n * Function: Commit.fn.js\n * Dependenies: mcdev@>=4.1.12, Copado Deployer@20.1\n * Homepage: https://github.com/Accenture/sfmc-devtools-copado#readme\n * Support: https://github.com/Accenture/sfmc-devtools-copado/issues\n * Git-Repository: https://github.com/Accenture/sfmc-devtools-copado.git\n * Copyright (c) 2022 Accenture. MIT licensed\n*/\n\n\n\"use strict\";\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// types/mcdev-copado.d.js\nvar require_mcdev_copado_d = __commonJS({\n  \"types/mcdev-copado.d.js\"(exports, module2) {\n    module2.exports = {};\n  }\n});\n\n// common/Config.js\nvar require_Config = __commonJS({\n  \"common/Config.js\"(exports, module2) {\n    module2.exports = {};\n  }\n});\n\n// common/Log.js\nvar require_Log = __commonJS({\n  \"common/Log.js\"(exports, module2) {\n    \"use strict\";\n    var execSync = require(\"child_process\").execSync;\n    var CONFIG2 = require_Config();\n    var Log2 = class {\n      static debug(msg) {\n        if (CONFIG2.debug) {\n          console.log(\"DEBUG:\", msg);\n        }\n      }\n      static warn(msg) {\n        console.log(\"\\u26A0\", msg);\n      }\n      static info(msg) {\n        console.log(msg);\n      }\n      static error(error, msg = \"Error\") {\n        console.log(\"\\u274C\", error);\n        error = JSON.stringify(error);\n        msg = JSON.stringify(msg);\n        execSync(`copado --error-message ${error} --progress ${msg}`);\n      }\n      static result(json, msg = \"Result attached\") {\n        if (typeof json !== \"string\") {\n          json = JSON.stringify(json);\n        }\n        console.log(\"\\u2705\", json);\n        json = JSON.stringify(`${msg}: ${json}`);\n        msg = JSON.stringify(msg);\n        execSync(`copado --result-data ${json} --progress ${msg}`);\n      }\n      static progress(msg) {\n        msg = JSON.stringify(msg);\n        execSync(`copado --progress ${msg}`);\n      }\n    };\n    module2.exports = Log2;\n  }\n});\n\n// common/Util.js\nvar require_Util = __commonJS({\n  \"common/Util.js\"(exports, module2) {\n    \"use strict\";\n    var fs = require(\"fs\");\n    var execSync = require(\"child_process\").execSync;\n    var TYPE2 = require_mcdev_copado_d();\n    var CONFIG2 = require_Config();\n    var Log2 = require_Log();\n    var Util2 = class {\n      static saveJsonFile(localPath, jsObj, beautify) {\n        const jsonString = beautify ? JSON.stringify(jsObj, null, 4) : JSON.stringify(jsObj);\n        fs.writeFileSync(localPath, jsonString, \"utf8\");\n      }\n      static push(destinationBranch) {\n        Util2.execCommand(\n          `Pushing updates to ${destinationBranch} branch`,\n          ['git push origin \"' + destinationBranch + '\"'],\n          \"Completed pushing branch\"\n        );\n      }\n      static execCommand(preMsg, command, postMsg) {\n        if (null != preMsg) {\n          Log2.progress(preMsg);\n        }\n        if (command && Array.isArray(command)) {\n          command = command.join(\" && \");\n        }\n        Log2.debug(\"\\u26A1 \" + command);\n        try {\n          execSync(command, { stdio: [0, 1, 2], stderr: \"inherit\" });\n        } catch (ex) {\n          Log2.info(ex.status + \": \" + ex.message);\n          throw new Error(ex);\n        }\n        if (null != postMsg) {\n          Log2.debug(\"\\u2714\\uFE0F  \" + postMsg);\n        }\n      }\n      static execCommandReturnStatus(preMsg, command, postMsg) {\n        if (null != preMsg) {\n          Log2.progress(preMsg);\n        }\n        if (command && Array.isArray(command)) {\n          command = command.join(\" && \");\n        }\n        Log2.debug(\"\\u26A1 \" + command);\n        let exitCode = null;\n        try {\n          execSync(command, { stdio: [0, 1, 2], stderr: \"inherit\" });\n          exitCode = 0;\n        } catch (ex) {\n          Log2.warn(\"\\u274C  \" + ex.status + \": \" + ex.message);\n          exitCode = ex.status;\n          return exitCode;\n        }\n        if (null != postMsg) {\n          Log2.progress(\"\\u2714\\uFE0F  \" + postMsg);\n        }\n        return exitCode;\n      }\n      static provideMCDevTools() {\n        if (fs.existsSync(\"package.json\")) {\n          Log2.debug(\"package.json found, assuming npm was already initialized\");\n        } else {\n          Util2.execCommand(\"Initializing npm\", [\"npm init -y\"], \"Completed initializing NPM\");\n        }\n        let installer;\n        if (!CONFIG2.installMcdevLocally) {\n          Util2.execCommand(\n            `Initializing Accenture SFMC DevTools (packaged version)`,\n            [\n              `npm link mcdev --no-audit --no-fund --ignore-scripts --omit=dev --omit=peer --omit=optional`,\n              \"mcdev --version\"\n            ],\n            \"Completed installing Accenture SFMC DevTools\"\n          );\n          return;\n        } else if (CONFIG2.mcdevVersion.charAt(0) === \"#\") {\n          installer = `accenture/sfmc-devtools${CONFIG2.mcdevVersion}`;\n        } else if (!CONFIG2.mcdevVersion) {\n          Log2.error(\"Please specify mcdev_version in pipeline & environment settings\");\n          throw new Error(\"Please specify mcdev_version in pipeline & environment settings\");\n        } else {\n          installer = `mcdev@${CONFIG2.mcdevVersion}`;\n        }\n        Util2.execCommand(\n          `Initializing Accenture SFMC DevTools (${installer})`,\n          [`npm install ${installer}`, \"node ./node_modules/mcdev/lib/cli.js --version\"],\n          \"Completed installing Accenture SFMC DevTools\"\n        );\n      }\n      static provideMCDevCredentials(credentials) {\n        Log2.info(\"Provide authentication\");\n        Util2.saveJsonFile(\".mcdev-auth.json\", credentials, true);\n      }\n      static convertSourceProperties(properties) {\n        const response = {};\n        for (const item of properties) {\n          response[item.copado__API_Name__c] = item.copado__Value__c;\n        }\n        return response;\n      }\n      static convertEnvVariables(envVariables) {\n        Object.keys(envVariables).map((key) => {\n          if (key.endsWith(\"Children\")) {\n            envVariables[key] = Util2._convertEnvChildVars(envVariables[key]);\n          } else {\n            envVariables[key] = Util2._convertEnvVars(envVariables[key]);\n          }\n        });\n      }\n      static _convertEnvVars(envVarArr) {\n        if (!envVarArr) {\n          return envVarArr;\n        }\n        if (typeof envVarArr === \"string\") {\n          envVarArr = JSON.parse(envVarArr);\n        }\n        const response = {};\n        for (const item of envVarArr) {\n          response[item.name] = item.value;\n        }\n        return response;\n      }\n      static _convertEnvChildVars(envChildVarArr) {\n        if (!envChildVarArr) {\n          return envChildVarArr;\n        }\n        if (typeof envChildVarArr === \"string\") {\n          envChildVarArr = JSON.parse(envChildVarArr);\n        }\n        const response = {};\n        for (const item of envChildVarArr) {\n          response[item.id] = Util2._convertEnvVars(item.environmentVariables);\n        }\n        return response;\n      }\n      static getBuName(credName, mid) {\n        let credBuName;\n        if (!credName) {\n          throw new Error('System Property \"credentialName\" not set');\n        }\n        if (!mid) {\n          throw new Error('System Property \"mid\" not set');\n        }\n        if (!fs.existsSync(CONFIG2.configFilePath)) {\n          throw new Error(\"Could not find config file \" + CONFIG2.configFilePath);\n        }\n        const config = JSON.parse(fs.readFileSync(CONFIG2.configFilePath, \"utf8\"));\n        if (config.credentials[credName] && config.credentials[credName].businessUnits) {\n          const myBuNameArr = Object.keys(config.credentials[credName].businessUnits).filter(\n            (buName) => config.credentials[credName].businessUnits[buName] == mid\n          );\n          if (myBuNameArr.length === 1) {\n            Log2.debug(\"BU Name is: \" + credName + \"/\" + myBuNameArr[0]);\n            credBuName = credName + \"/\" + myBuNameArr[0];\n          } else {\n            throw new Error(`MID ${mid} not found for ${credName}`);\n          }\n        }\n        return credBuName;\n      }\n    };\n    module2.exports = Util2;\n  }\n});\n\n// common/Copado.js\nvar require_Copado = __commonJS({\n  \"common/Copado.js\"(exports, module2) {\n    \"use strict\";\n    var fs = require(\"fs\");\n    var exec = require(\"child_process\").exec;\n    var TYPE2 = require_mcdev_copado_d();\n    var Log2 = require_Log();\n    var Util2 = require_Util();\n    var Copado2 = class {\n      static mcdevInit(credentials, credentialName, url) {\n        Util2.execCommand(\n          `Initializing mcdev: ${credentialName}, ${credentials[credentialName].client_id}\", \"${credentials[credentialName].client_secret}\", \"${credentials[credentialName].auth_url}\", \"${url}\", ${credentials[credentialName].account_id}`,\n          [\n            `mcdev init --y.credentialName \"${credentialName}\" --y.client_id \"${credentials[credentialName].client_id}\" --y.client_secret \"${credentials[credentialName].client_secret}\" --y.auth_url \"${credentials[credentialName].auth_url}\" --y.gitRemoteUrl \"${url}\" --y.account_id ${credentials[credentialName].account_id} --y.downloadBUs \"false\" --y.gitPush \"true\"`\n          ],\n          \"Mcdev initialized!\"\n        );\n      }\n      static attachJson(localPath, parentSfid, async = false, preMsg) {\n        Copado2._attachFile(localPath, async, parentSfid, preMsg);\n      }\n      static async attachLog(localPath) {\n        Copado2._attachFile(localPath, true);\n      }\n      static _attachFile(localPath, async = false, parentSfid, preMsg, postMsg = \"Completed uploading file\") {\n        const command = `copado --uploadfile \"${localPath}\"` + (parentSfid ? ` --parentid \"${parentSfid}\"` : \"\");\n        if (async) {\n          Log2.debug(\"\\u26A1 \" + command);\n          try {\n            exec(command);\n          } catch (ex) {\n            Log2.info(ex.status + \": \" + ex.message);\n            throw new Error(ex);\n          }\n        } else {\n          if (!preMsg) {\n            preMsg = \"Uploading file \" + localPath;\n            if (parentSfid) {\n              preMsg += ` to ${parentSfid}`;\n            }\n          }\n          Util2.execCommand(preMsg, [command], postMsg);\n        }\n      }\n      static _downloadFile(fileSFID, preMsg) {\n        if (fileSFID) {\n          if (!preMsg) {\n            preMsg = `Download ${fileSFID}.`;\n          }\n          Util2.execCommand(preMsg, `copado --downloadfiles \"${fileSFID}\"`, \"Completed download\");\n        } else {\n          throw new Error(\"fileSalesforceId is not set\");\n        }\n      }\n      static getJsonFile(fileSFID, fileName, preMsg) {\n        Copado2._downloadFile(fileSFID, preMsg);\n        return JSON.parse(fs.readFileSync(fileName, \"utf8\"));\n      }\n      static checkoutSrc(workingBranch, createBranch = false) {\n        Util2.execCommand(\n          `Switching to ${workingBranch} branch`,\n          [`copado-git-get ${createBranch ? \"--create \" : \"\"}\"${workingBranch}\"`],\n          \"Completed creating/checking out branch\"\n        );\n      }\n      static deleteBranch(featureBranch) {\n        Util2.execCommand(\n          `Deleting branch ${featureBranch} on server`,\n          [`git push origin --delete ${featureBranch}`],\n          \"Completed deleting server branch \" + featureBranch\n        );\n        Util2.execCommand(\n          `Deleting branch ${featureBranch} locally`,\n          [`git branch --delete --force ${featureBranch}`],\n          \"Completed deleting local branch \" + featureBranch\n        );\n      }\n      static async uploadToolLogs() {\n        Log2.debug(\"Getting mcdev logs\");\n        try {\n          const logsAttached = [];\n          for (const file of fs.readdirSync(\"logs\")) {\n            Log2.debug(\"- \" + file);\n            logsAttached.push(Copado2.attachLog(\"logs/\" + file));\n          }\n          const response = await Promise.all(logsAttached);\n          Log2.debug(\"Attached mcdev logs\");\n          return response;\n        } catch (ex) {\n          Log2.debug(\"attaching mcdev logs failed:\" + ex.message);\n        }\n      }\n    };\n    module2.exports = Copado2;\n  }\n});\n\n// common/Commit.js\nvar require_Commit = __commonJS({\n  \"common/Commit.js\"(exports, module2) {\n    \"use strict\";\n    var fs = require(\"fs\");\n    var execSync = require(\"child_process\").execSync;\n    var TYPE2 = require_mcdev_copado_d();\n    var CONFIG2 = require_Config();\n    var Log2 = require_Log();\n    var Util2 = require_Util();\n    var Commit2 = class {\n      static async retrieveCommitSelection(sourceBU, commitSelectionArr) {\n        const mcdev = require(\"../tmp/node_modules/mcdev/lib/\");\n        mcdev.setSkipInteraction(true);\n        commitSelectionArr = commitSelectionArr.filter((item) => item.a === \"add\");\n        const typeKeyMap = {};\n        for (const item of commitSelectionArr) {\n          if (!typeKeyMap[item.t]) {\n            typeKeyMap[item.t] = [];\n          }\n          const jObj = JSON.parse(item.j);\n          typeKeyMap[item.t].push(jObj.newKey || jObj.key);\n        }\n        const typeArr = [...new Set(commitSelectionArr.map((item) => item.t))];\n        await mcdev.retrieve(sourceBU, typeKeyMap, null, false);\n        const fileArr = (await Promise.all(\n          typeArr.map((type) => {\n            const keyArr = [\n              ...new Set(\n                commitSelectionArr.filter((item) => item.t === type).map((item) => {\n                  const jObj = JSON.parse(item.j);\n                  return jObj.newKey || jObj.key;\n                })\n              )\n            ];\n            return mcdev.getFilesToCommit(sourceBU, type.split(\"-\")[0], keyArr);\n          })\n        )).flat();\n        return fileArr;\n      }\n      static addSelectedComponents(gitAddArr) {\n        for (const filePath of gitAddArr) {\n          if (fs.existsSync(filePath)) {\n            Util2.execCommand(null, ['git add \"' + filePath + '\"'], \"staged \" + filePath);\n          } else {\n            Log2.warn(\"\\u274C  could not find \" + filePath);\n          }\n        }\n      }\n      static commit(originalSelection) {\n        const gitDiffArr = execSync(\"git diff --staged --name-only\").toString().split(\"\\n\").map((item) => item.trim()).filter((item) => !!item);\n        Log2.debug(\"Git diff ended with the result:\");\n        Log2.debug(gitDiffArr);\n        if (Array.isArray(gitDiffArr) && gitDiffArr.length) {\n          Util2.execCommand(\n            \"Committing changes to branch\",\n            ['git commit -n -m \"' + CONFIG2.commitMessage + '\"'],\n            \"Completed committing\"\n          );\n          const result = {\n            committed: gitDiffArr,\n            noChangesFound: originalSelection.map((item) => item.replace(new RegExp(\"\\\\\\\\\", \"g\"), \"/\")).filter(\n              (item) => !gitDiffArr.includes(item)\n            )\n          };\n          Log2.result(\n            result,\n            `Committed ${result.committed.filter((item) => item.endsWith(\".json\")).length} items with ${result.committed.length} files`\n          );\n        } else {\n          Log2.error(\n            \"Nothing to commit as all selected components have the same content as already exists in Git. \" + JSON.stringify(originalSelection),\n            \"Nothing to commit\"\n          );\n          throw new Error(\"Nothing to commit\");\n        }\n      }\n    };\n    module2.exports = Commit2;\n  }\n});\n\n// Commit.fn.js\nvar resolve = require(\"path\").resolve;\nvar TYPE = require_mcdev_copado_d();\nvar CONFIG = require_Config();\nvar Log = require_Log();\nvar Util = require_Util();\nvar Copado = require_Copado();\nvar Commit = require_Commit();\nCONFIG.mcdevCopadoVersion = \"1.3.0\";\nCONFIG.credentialNameSource = process.env.credentialNameSource;\nCONFIG.credentialNameTarget = null;\nCONFIG.credentials = process.env.credentials;\nCONFIG.configFilePath = \".mcdevrc.json\";\nCONFIG.debug = process.env.debug === \"true\" ? true : false;\nCONFIG.installMcdevLocally = process.env.installMcdevLocally === \"true\" ? true : false;\nCONFIG.mainBranch = process.env.main_branch;\nCONFIG.mcdevVersion = process.env.mcdev_version;\nCONFIG.metadataFilePath = \"mcmetadata.json\";\nCONFIG.source_mid = process.env.source_mid;\nCONFIG.tmpDirectory = \"../tmp\";\nCONFIG.source_sfid = null;\nCONFIG.commitMessage = process.env.commit_message;\nCONFIG.featureBranch = process.env.feature_branch;\nCONFIG.fileSelectionSalesforceId = process.env.metadata_file;\nCONFIG.fileSelectionFileName = \"Copado Commit changes\";\nCONFIG.recreateFeatureBranch = process.env.recreateFeatureBranch === \"true\" ? true : false;\nCONFIG.envVariables = {\n  source: null,\n  sourceChildren: null,\n  destination: null,\n  destinationChildren: null\n};\nCONFIG.deltaPackageLog = null;\nCONFIG.destinationBranch = null;\nCONFIG.fileUpdatedSelectionSfid = null;\nCONFIG.git_depth = null;\nCONFIG.merge_strategy = null;\nCONFIG.promotionBranch = null;\nCONFIG.promotionName = null;\nCONFIG.target_mid = null;\nasync function run() {\n  Log.info(\"Commit.js started\");\n  Log.debug(\"\");\n  Log.debug(\"Parameters\");\n  Log.debug(\"===================\");\n  try {\n    CONFIG.credentials = JSON.parse(CONFIG.credentials);\n  } catch (ex) {\n    Log.error(\"Could not parse credentials\");\n    throw ex;\n  }\n  Util.convertEnvVariables(CONFIG.envVariables);\n  Log.debug(CONFIG);\n  if (!CONFIG.credentials[CONFIG.credentialNameSource]) {\n    Log.error(`No credentials found for source (${CONFIG.credentialNameSource})`);\n    throw new Error(`No source credentials`);\n  }\n  Log.debug(\"Environment\");\n  Log.debug(\"===================\");\n  if (CONFIG.debug) {\n    Util.execCommand(null, \"npm --version\", null);\n    Util.execCommand(null, \"node --version\", null);\n    Util.execCommand(null, \"git version\", null);\n  }\n  Log.debug(`Change Working directory to: ${CONFIG.tmpDirectory}`);\n  try {\n    Util.execCommand(null, [\"git config --global --add safe.directory /tmp\"]);\n  } catch {\n    try {\n      Util.execCommand(null, [\n        \"git config --global --add safe.directory \" + resolve(CONFIG.tmpDirectory)\n      ]);\n    } catch {\n      Log.error(\"Could not set tmp directoy as safe directory\");\n    }\n  }\n  process.chdir(CONFIG.tmpDirectory);\n  Log.debug(process.cwd());\n  Log.info(\"\");\n  Log.info(\"Clone repository\");\n  Log.info(\"===================\");\n  Log.info(\"\");\n  try {\n    Copado.checkoutSrc(CONFIG.mainBranch);\n    try {\n      if (CONFIG.recreateFeatureBranch) {\n        Copado.deleteBranch(CONFIG.featureBranch);\n      }\n    } catch (ex) {\n      Log.warn(\"Delete feature branch failed:\" + ex.message);\n    }\n    Copado.checkoutSrc(CONFIG.featureBranch, true);\n  } catch (ex) {\n    Log.error(\"Checkout to feature and/or master branch failed:\" + ex.message);\n    throw ex;\n  }\n  let commitSelectionArr;\n  try {\n    Log.info(\"\");\n    Log.info(\n      `Add selected components defined in ${CONFIG.fileSelectionSalesforceId} to metadata JSON`\n    );\n    Log.info(\"===================\");\n    Log.info(\"\");\n    commitSelectionArr = Copado.getJsonFile(\n      CONFIG.fileSelectionSalesforceId,\n      CONFIG.fileSelectionFileName,\n      \"Retrieving list of selected items\"\n    );\n    if (!Array.isArray(commitSelectionArr) || commitSelectionArr.length === 0) {\n      throw new Error(\n        \"Copado has not registered any files selected for commit. Please go back and select at least one item in the Commit page.\"\n      );\n    }\n  } catch (ex) {\n    Log.error(\"Getting Commit-selection file failed:\" + ex.message);\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Preparing\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Util.provideMCDevTools();\n    Util.provideMCDevCredentials(CONFIG.credentials);\n  } catch (ex) {\n    Log.error(\"initializing failed: \" + ex.message);\n    throw ex;\n  }\n  let sourceBU;\n  let gitAddArr;\n  try {\n    Log.info(\"\");\n    Log.info(\"Get source BU\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    sourceBU = Util.getBuName(CONFIG.credentialNameSource, CONFIG.source_mid);\n  } catch (ex) {\n    Log.error(\"Getting Source BU failed: \" + ex.message);\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Retrieve components\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    gitAddArr = await Commit.retrieveCommitSelection(sourceBU, commitSelectionArr);\n  } catch (ex) {\n    Log.error(\"Retrieving failed: \" + ex.message);\n    Copado.uploadToolLogs();\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Add components in metadata JSON to Git history\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Commit.addSelectedComponents(gitAddArr);\n  } catch (ex) {\n    Log.error(\"git add failed:\" + ex.message);\n    Copado.uploadToolLogs();\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Commit\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Commit.commit(gitAddArr);\n    Log.info(\"Push\");\n    Log.info(\"===================\");\n    Util.push(CONFIG.featureBranch);\n  } catch (ex) {\n    Log.error(\"git commit / push failed:\" + ex.message);\n    Copado.uploadToolLogs();\n    throw ex;\n  }\n  Log.info(\"\");\n  Log.info(\"===================\");\n  Log.info(\"\");\n  Log.info(\"Commit.js done\");\n  Copado.uploadToolLogs();\n}\nrun();",
          "copado__Timeout__c": 30,
          "copado__Type__c": "Custom",
          "copado__Version__c": "1",
          "copado__Worker_Size__c": "S"
        },
        {
          "attributes": {
            "type": "copado__Function__c",
            "url": "/services/data/v57.0/sobjects/copado__Function__c/a0k7Q000000nwHHQAY"
          },
          "Id": "a0k7Q000000nwHHQAY",
          "Name": "sfmc_Deploy",
          "copado__API_Name__c": "sfmc_Deploy",
          "copado__Image_Name__c": "0onz6fxsbyolcopmojdzlxa5vzgsts-sfmc-devtools:v1.0",
          "copado__Options__c": "[]",
          "copado__Parameters__c": "[{\"required\":true,\"name\":\"credentialNameSource\",\"defaultValue\":\"{$Source.Property.credential_name}\"},{\"required\":true,\"name\":\"credentialNameTarget\",\"defaultValue\":\"{$Destination.Property.credential_name}\"},{\"required\":true,\"name\":\"credentials\",\"defaultValue\":\"{$Pipeline.Property.mc_credentials}\"},{\"required\":true,\"name\":\"git_json\",\"defaultValue\":\"{$Context.Repository.Credential}\"},{\"required\":true,\"name\":\"main_branch\",\"defaultValue\":\"{$Pipeline.Main_Branch__c}\"},{\"required\":true,\"name\":\"merge_strategy\",\"defaultValue\":\"theirs\"},{\"required\":true,\"name\":\"metadata_file\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.fileWithSelectedChanges}\"},{\"required\":true,\"name\":\"promotionBranch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.promotionBranchName}\"},{\"required\":true,\"name\":\"promotionName\",\"defaultValue\":\"{$Context.JobExecution__r.Deployment__r.Promotion__r.Name}\"},{\"required\":true,\"name\":\"source_mid\",\"defaultValue\":\"{$Source.Property.mid}\"},{\"required\":true,\"name\":\"sourceProperties\",\"defaultValue\":\"{$Context.apex.mcdo_GetPropertiesOfUSsInPromotion}\"},{\"required\":true,\"name\":\"target_mid\",\"defaultValue\":\"{$Destination.Property.mid}\"},{\"required\":false,\"name\":\"debug\",\"defaultValue\":\"{$Pipeline.Property.debug}\"},{\"required\":false,\"name\":\"deployNTimes\",\"defaultValue\":\"{$Pipeline.Property.deployNTimes}\"},{\"required\":false,\"name\":\"envVariablesDestination\",\"defaultValue\":\"{$Destination.apex.EnvironmentVariables}\"},{\"required\":false,\"name\":\"envVariablesDestinationChildren\",\"defaultValue\":\"{$Destination.apex.mcdo_ChildEnvironmentVariables}\"},{\"required\":false,\"name\":\"envVariablesSource\",\"defaultValue\":\"{$Context.apex.mcdo_SourceEnvironmentVariables}\"},{\"required\":false,\"name\":\"envVariablesSourceChildren\",\"defaultValue\":\"{$Context.apex.mcdo_SourceChildEnvironmentVariables}\"},{\"required\":false,\"name\":\"installMcdevLocally\",\"defaultValue\":\"{$Pipeline.Property.installMcdevLocally}\"},{\"required\":false,\"name\":\"mcdev_version\",\"defaultValue\":\"{$Pipeline.Property.mc_devtools_version}\"},{\"required\":false,\"name\":\"toBranch\",\"defaultValue\":\"{$Context.JobExecution__r.DataJson.destinationBranchName}\"}]",
          "copado__Script__c": "#!/usr/bin/env node\n#!/usr/bin/env node\n\n/*\n * mcdev-copado v1.3.0 (built 2022-12-05T15:06:59.912Z)\n * Function: Deploy.fn.js\n * Dependenies: mcdev@>=4.1.12, Copado Deployer@20.1\n * Homepage: https://github.com/Accenture/sfmc-devtools-copado#readme\n * Support: https://github.com/Accenture/sfmc-devtools-copado/issues\n * Git-Repository: https://github.com/Accenture/sfmc-devtools-copado.git\n * Copyright (c) 2022 Accenture. MIT licensed\n*/\n\n\n\"use strict\";\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// types/mcdev-copado.d.js\nvar require_mcdev_copado_d = __commonJS({\n  \"types/mcdev-copado.d.js\"(exports, module2) {\n    module2.exports = {};\n  }\n});\n\n// common/Config.js\nvar require_Config = __commonJS({\n  \"common/Config.js\"(exports, module2) {\n    module2.exports = {};\n  }\n});\n\n// common/Log.js\nvar require_Log = __commonJS({\n  \"common/Log.js\"(exports, module2) {\n    \"use strict\";\n    var execSync2 = require(\"child_process\").execSync;\n    var CONFIG2 = require_Config();\n    var Log2 = class {\n      static debug(msg) {\n        if (CONFIG2.debug) {\n          console.log(\"DEBUG:\", msg);\n        }\n      }\n      static warn(msg) {\n        console.log(\"\\u26A0\", msg);\n      }\n      static info(msg) {\n        console.log(msg);\n      }\n      static error(error, msg = \"Error\") {\n        console.log(\"\\u274C\", error);\n        error = JSON.stringify(error);\n        msg = JSON.stringify(msg);\n        execSync2(`copado --error-message ${error} --progress ${msg}`);\n      }\n      static result(json, msg = \"Result attached\") {\n        if (typeof json !== \"string\") {\n          json = JSON.stringify(json);\n        }\n        console.log(\"\\u2705\", json);\n        json = JSON.stringify(`${msg}: ${json}`);\n        msg = JSON.stringify(msg);\n        execSync2(`copado --result-data ${json} --progress ${msg}`);\n      }\n      static progress(msg) {\n        msg = JSON.stringify(msg);\n        execSync2(`copado --progress ${msg}`);\n      }\n    };\n    module2.exports = Log2;\n  }\n});\n\n// common/Util.js\nvar require_Util = __commonJS({\n  \"common/Util.js\"(exports, module2) {\n    \"use strict\";\n    var fs2 = require(\"fs\");\n    var execSync2 = require(\"child_process\").execSync;\n    var TYPE2 = require_mcdev_copado_d();\n    var CONFIG2 = require_Config();\n    var Log2 = require_Log();\n    var Util2 = class {\n      static saveJsonFile(localPath, jsObj, beautify) {\n        const jsonString = beautify ? JSON.stringify(jsObj, null, 4) : JSON.stringify(jsObj);\n        fs2.writeFileSync(localPath, jsonString, \"utf8\");\n      }\n      static push(destinationBranch) {\n        Util2.execCommand(\n          `Pushing updates to ${destinationBranch} branch`,\n          ['git push origin \"' + destinationBranch + '\"'],\n          \"Completed pushing branch\"\n        );\n      }\n      static execCommand(preMsg, command, postMsg) {\n        if (null != preMsg) {\n          Log2.progress(preMsg);\n        }\n        if (command && Array.isArray(command)) {\n          command = command.join(\" && \");\n        }\n        Log2.debug(\"\\u26A1 \" + command);\n        try {\n          execSync2(command, { stdio: [0, 1, 2], stderr: \"inherit\" });\n        } catch (ex) {\n          Log2.info(ex.status + \": \" + ex.message);\n          throw new Error(ex);\n        }\n        if (null != postMsg) {\n          Log2.debug(\"\\u2714\\uFE0F  \" + postMsg);\n        }\n      }\n      static execCommandReturnStatus(preMsg, command, postMsg) {\n        if (null != preMsg) {\n          Log2.progress(preMsg);\n        }\n        if (command && Array.isArray(command)) {\n          command = command.join(\" && \");\n        }\n        Log2.debug(\"\\u26A1 \" + command);\n        let exitCode = null;\n        try {\n          execSync2(command, { stdio: [0, 1, 2], stderr: \"inherit\" });\n          exitCode = 0;\n        } catch (ex) {\n          Log2.warn(\"\\u274C  \" + ex.status + \": \" + ex.message);\n          exitCode = ex.status;\n          return exitCode;\n        }\n        if (null != postMsg) {\n          Log2.progress(\"\\u2714\\uFE0F  \" + postMsg);\n        }\n        return exitCode;\n      }\n      static provideMCDevTools() {\n        if (fs2.existsSync(\"package.json\")) {\n          Log2.debug(\"package.json found, assuming npm was already initialized\");\n        } else {\n          Util2.execCommand(\"Initializing npm\", [\"npm init -y\"], \"Completed initializing NPM\");\n        }\n        let installer;\n        if (!CONFIG2.installMcdevLocally) {\n          Util2.execCommand(\n            `Initializing Accenture SFMC DevTools (packaged version)`,\n            [\n              `npm link mcdev --no-audit --no-fund --ignore-scripts --omit=dev --omit=peer --omit=optional`,\n              \"mcdev --version\"\n            ],\n            \"Completed installing Accenture SFMC DevTools\"\n          );\n          return;\n        } else if (CONFIG2.mcdevVersion.charAt(0) === \"#\") {\n          installer = `accenture/sfmc-devtools${CONFIG2.mcdevVersion}`;\n        } else if (!CONFIG2.mcdevVersion) {\n          Log2.error(\"Please specify mcdev_version in pipeline & environment settings\");\n          throw new Error(\"Please specify mcdev_version in pipeline & environment settings\");\n        } else {\n          installer = `mcdev@${CONFIG2.mcdevVersion}`;\n        }\n        Util2.execCommand(\n          `Initializing Accenture SFMC DevTools (${installer})`,\n          [`npm install ${installer}`, \"node ./node_modules/mcdev/lib/cli.js --version\"],\n          \"Completed installing Accenture SFMC DevTools\"\n        );\n      }\n      static provideMCDevCredentials(credentials) {\n        Log2.info(\"Provide authentication\");\n        Util2.saveJsonFile(\".mcdev-auth.json\", credentials, true);\n      }\n      static convertSourceProperties(properties) {\n        const response = {};\n        for (const item of properties) {\n          response[item.copado__API_Name__c] = item.copado__Value__c;\n        }\n        return response;\n      }\n      static convertEnvVariables(envVariables) {\n        Object.keys(envVariables).map((key) => {\n          if (key.endsWith(\"Children\")) {\n            envVariables[key] = Util2._convertEnvChildVars(envVariables[key]);\n          } else {\n            envVariables[key] = Util2._convertEnvVars(envVariables[key]);\n          }\n        });\n      }\n      static _convertEnvVars(envVarArr) {\n        if (!envVarArr) {\n          return envVarArr;\n        }\n        if (typeof envVarArr === \"string\") {\n          envVarArr = JSON.parse(envVarArr);\n        }\n        const response = {};\n        for (const item of envVarArr) {\n          response[item.name] = item.value;\n        }\n        return response;\n      }\n      static _convertEnvChildVars(envChildVarArr) {\n        if (!envChildVarArr) {\n          return envChildVarArr;\n        }\n        if (typeof envChildVarArr === \"string\") {\n          envChildVarArr = JSON.parse(envChildVarArr);\n        }\n        const response = {};\n        for (const item of envChildVarArr) {\n          response[item.id] = Util2._convertEnvVars(item.environmentVariables);\n        }\n        return response;\n      }\n      static getBuName(credName, mid) {\n        let credBuName;\n        if (!credName) {\n          throw new Error('System Property \"credentialName\" not set');\n        }\n        if (!mid) {\n          throw new Error('System Property \"mid\" not set');\n        }\n        if (!fs2.existsSync(CONFIG2.configFilePath)) {\n          throw new Error(\"Could not find config file \" + CONFIG2.configFilePath);\n        }\n        const config = JSON.parse(fs2.readFileSync(CONFIG2.configFilePath, \"utf8\"));\n        if (config.credentials[credName] && config.credentials[credName].businessUnits) {\n          const myBuNameArr = Object.keys(config.credentials[credName].businessUnits).filter(\n            (buName) => config.credentials[credName].businessUnits[buName] == mid\n          );\n          if (myBuNameArr.length === 1) {\n            Log2.debug(\"BU Name is: \" + credName + \"/\" + myBuNameArr[0]);\n            credBuName = credName + \"/\" + myBuNameArr[0];\n          } else {\n            throw new Error(`MID ${mid} not found for ${credName}`);\n          }\n        }\n        return credBuName;\n      }\n    };\n    module2.exports = Util2;\n  }\n});\n\n// common/Copado.js\nvar require_Copado = __commonJS({\n  \"common/Copado.js\"(exports, module2) {\n    \"use strict\";\n    var fs2 = require(\"fs\");\n    var exec = require(\"child_process\").exec;\n    var TYPE2 = require_mcdev_copado_d();\n    var Log2 = require_Log();\n    var Util2 = require_Util();\n    var Copado2 = class {\n      static mcdevInit(credentials, credentialName, url) {\n        Util2.execCommand(\n          `Initializing mcdev: ${credentialName}, ${credentials[credentialName].client_id}\", \"${credentials[credentialName].client_secret}\", \"${credentials[credentialName].auth_url}\", \"${url}\", ${credentials[credentialName].account_id}`,\n          [\n            `mcdev init --y.credentialName \"${credentialName}\" --y.client_id \"${credentials[credentialName].client_id}\" --y.client_secret \"${credentials[credentialName].client_secret}\" --y.auth_url \"${credentials[credentialName].auth_url}\" --y.gitRemoteUrl \"${url}\" --y.account_id ${credentials[credentialName].account_id} --y.downloadBUs \"false\" --y.gitPush \"true\"`\n          ],\n          \"Mcdev initialized!\"\n        );\n      }\n      static attachJson(localPath, parentSfid, async = false, preMsg) {\n        Copado2._attachFile(localPath, async, parentSfid, preMsg);\n      }\n      static async attachLog(localPath) {\n        Copado2._attachFile(localPath, true);\n      }\n      static _attachFile(localPath, async = false, parentSfid, preMsg, postMsg = \"Completed uploading file\") {\n        const command = `copado --uploadfile \"${localPath}\"` + (parentSfid ? ` --parentid \"${parentSfid}\"` : \"\");\n        if (async) {\n          Log2.debug(\"\\u26A1 \" + command);\n          try {\n            exec(command);\n          } catch (ex) {\n            Log2.info(ex.status + \": \" + ex.message);\n            throw new Error(ex);\n          }\n        } else {\n          if (!preMsg) {\n            preMsg = \"Uploading file \" + localPath;\n            if (parentSfid) {\n              preMsg += ` to ${parentSfid}`;\n            }\n          }\n          Util2.execCommand(preMsg, [command], postMsg);\n        }\n      }\n      static _downloadFile(fileSFID, preMsg) {\n        if (fileSFID) {\n          if (!preMsg) {\n            preMsg = `Download ${fileSFID}.`;\n          }\n          Util2.execCommand(preMsg, `copado --downloadfiles \"${fileSFID}\"`, \"Completed download\");\n        } else {\n          throw new Error(\"fileSalesforceId is not set\");\n        }\n      }\n      static getJsonFile(fileSFID, fileName, preMsg) {\n        Copado2._downloadFile(fileSFID, preMsg);\n        return JSON.parse(fs2.readFileSync(fileName, \"utf8\"));\n      }\n      static checkoutSrc(workingBranch, createBranch = false) {\n        Util2.execCommand(\n          `Switching to ${workingBranch} branch`,\n          [`copado-git-get ${createBranch ? \"--create \" : \"\"}\"${workingBranch}\"`],\n          \"Completed creating/checking out branch\"\n        );\n      }\n      static deleteBranch(featureBranch) {\n        Util2.execCommand(\n          `Deleting branch ${featureBranch} on server`,\n          [`git push origin --delete ${featureBranch}`],\n          \"Completed deleting server branch \" + featureBranch\n        );\n        Util2.execCommand(\n          `Deleting branch ${featureBranch} locally`,\n          [`git branch --delete --force ${featureBranch}`],\n          \"Completed deleting local branch \" + featureBranch\n        );\n      }\n      static async uploadToolLogs() {\n        Log2.debug(\"Getting mcdev logs\");\n        try {\n          const logsAttached = [];\n          for (const file of fs2.readdirSync(\"logs\")) {\n            Log2.debug(\"- \" + file);\n            logsAttached.push(Copado2.attachLog(\"logs/\" + file));\n          }\n          const response = await Promise.all(logsAttached);\n          Log2.debug(\"Attached mcdev logs\");\n          return response;\n        } catch (ex) {\n          Log2.debug(\"attaching mcdev logs failed:\" + ex.message);\n        }\n      }\n    };\n    module2.exports = Copado2;\n  }\n});\n\n// common/Commit.js\nvar require_Commit = __commonJS({\n  \"common/Commit.js\"(exports, module2) {\n    \"use strict\";\n    var fs2 = require(\"fs\");\n    var execSync2 = require(\"child_process\").execSync;\n    var TYPE2 = require_mcdev_copado_d();\n    var CONFIG2 = require_Config();\n    var Log2 = require_Log();\n    var Util2 = require_Util();\n    var Commit2 = class {\n      static async retrieveCommitSelection(sourceBU, commitSelectionArr) {\n        const mcdev = require(\"../tmp/node_modules/mcdev/lib/\");\n        mcdev.setSkipInteraction(true);\n        commitSelectionArr = commitSelectionArr.filter((item) => item.a === \"add\");\n        const typeKeyMap = {};\n        for (const item of commitSelectionArr) {\n          if (!typeKeyMap[item.t]) {\n            typeKeyMap[item.t] = [];\n          }\n          const jObj = JSON.parse(item.j);\n          typeKeyMap[item.t].push(jObj.newKey || jObj.key);\n        }\n        const typeArr = [...new Set(commitSelectionArr.map((item) => item.t))];\n        await mcdev.retrieve(sourceBU, typeKeyMap, null, false);\n        const fileArr = (await Promise.all(\n          typeArr.map((type) => {\n            const keyArr = [\n              ...new Set(\n                commitSelectionArr.filter((item) => item.t === type).map((item) => {\n                  const jObj = JSON.parse(item.j);\n                  return jObj.newKey || jObj.key;\n                })\n              )\n            ];\n            return mcdev.getFilesToCommit(sourceBU, type.split(\"-\")[0], keyArr);\n          })\n        )).flat();\n        return fileArr;\n      }\n      static addSelectedComponents(gitAddArr) {\n        for (const filePath of gitAddArr) {\n          if (fs2.existsSync(filePath)) {\n            Util2.execCommand(null, ['git add \"' + filePath + '\"'], \"staged \" + filePath);\n          } else {\n            Log2.warn(\"\\u274C  could not find \" + filePath);\n          }\n        }\n      }\n      static commit(originalSelection) {\n        const gitDiffArr = execSync2(\"git diff --staged --name-only\").toString().split(\"\\n\").map((item) => item.trim()).filter((item) => !!item);\n        Log2.debug(\"Git diff ended with the result:\");\n        Log2.debug(gitDiffArr);\n        if (Array.isArray(gitDiffArr) && gitDiffArr.length) {\n          Util2.execCommand(\n            \"Committing changes to branch\",\n            ['git commit -n -m \"' + CONFIG2.commitMessage + '\"'],\n            \"Completed committing\"\n          );\n          const result = {\n            committed: gitDiffArr,\n            noChangesFound: originalSelection.map((item) => item.replace(new RegExp(\"\\\\\\\\\", \"g\"), \"/\")).filter(\n              (item) => !gitDiffArr.includes(item)\n            )\n          };\n          Log2.result(\n            result,\n            `Committed ${result.committed.filter((item) => item.endsWith(\".json\")).length} items with ${result.committed.length} files`\n          );\n        } else {\n          Log2.error(\n            \"Nothing to commit as all selected components have the same content as already exists in Git. \" + JSON.stringify(originalSelection),\n            \"Nothing to commit\"\n          );\n          throw new Error(\"Nothing to commit\");\n        }\n      }\n    };\n    module2.exports = Commit2;\n  }\n});\n\n// Deploy.fn.js\nvar fs = require(\"fs\");\nvar execSync = require(\"child_process\").execSync;\nvar resolve = require(\"path\").resolve;\nvar TYPE = require_mcdev_copado_d();\nvar CONFIG = require_Config();\nvar Log = require_Log();\nvar Util = require_Util();\nvar Copado = require_Copado();\nvar Commit = require_Commit();\nCONFIG.mcdevCopadoVersion = \"1.3.0\";\nCONFIG.credentialNameSource = process.env.credentialNameSource;\nCONFIG.credentialNameTarget = process.env.credentialNameTarget;\nCONFIG.credentials = process.env.credentials;\nCONFIG.configFilePath = \".mcdevrc.json\";\nCONFIG.debug = process.env.debug === \"true\" ? true : false;\nCONFIG.installMcdevLocally = process.env.installMcdevLocally === \"true\" ? true : false;\nCONFIG.mainBranch = process.env.main_branch;\nCONFIG.mcdevVersion = process.env.mcdev_version;\nCONFIG.metadataFilePath = \"mcmetadata.json\";\nCONFIG.source_mid = process.env.source_mid;\nCONFIG.tmpDirectory = \"../tmp\";\nCONFIG.source_sfid = null;\nCONFIG.commitMessage = null;\nCONFIG.featureBranch = null;\nCONFIG.recreateFeatureBranch = null;\nCONFIG.envVariables = {\n  source: process.env.envVariablesSource,\n  sourceChildren: process.env.envVariablesSourceChildren,\n  destination: process.env.envVariablesDestination,\n  destinationChildren: process.env.envVariablesDestinationChildren\n};\nCONFIG.deltaPackageLog = \"docs/deltaPackage/delta_package.md\";\nCONFIG.destinationBranch = process.env.toBranch;\nCONFIG.fileSelectionFileName = \"Copado Deploy changes\";\nCONFIG.fileSelectionSalesforceId = process.env.metadata_file;\nCONFIG.fileUpdatedSelectionSfid = null;\nCONFIG.git_depth = 100;\nCONFIG.merge_strategy = process.env.merge_strategy;\nCONFIG.promotionBranch = process.env.promotionBranch;\nCONFIG.promotionName = process.env.promotionName;\nCONFIG.target_mid = process.env.target_mid;\nCONFIG.sourceProperties = process.env.sourceProperties;\nCONFIG.deployNTimes = process.env.deployNTimes === \"true\" ? true : false;\nasync function run() {\n  Log.info(\"Deploy.js started\");\n  Log.debug(\"\");\n  Log.debug(\"Parameters\");\n  Log.debug(\"===================\");\n  try {\n    CONFIG.credentials = JSON.parse(CONFIG.credentials);\n  } catch (ex) {\n    Log.error(\"Could not parse credentials\");\n    throw ex;\n  }\n  try {\n    CONFIG.sourceProperties = JSON.parse(CONFIG.sourceProperties);\n  } catch (ex) {\n    Log.error(\"Could not parse sourceProperties\");\n    throw ex;\n  }\n  Util.convertEnvVariables(CONFIG.envVariables);\n  CONFIG.sourceProperties = Util.convertSourceProperties(CONFIG.sourceProperties);\n  CONFIG.source_mid = CONFIG.sourceProperties.mid;\n  CONFIG.credentialNameSource = CONFIG.sourceProperties.credential_name;\n  Log.debug(CONFIG);\n  if (!CONFIG.credentials[CONFIG.credentialNameSource]) {\n    Log.error(`No credentials found for source (${CONFIG.credentialNameSource})`);\n    throw new Error(`No source credentials`);\n  }\n  if (!CONFIG.credentials[CONFIG.credentialNameTarget]) {\n    Log.error(`No credentials found for target (${CONFIG.credentialNameTarget})`);\n    throw new Error(`No target credentials`);\n  }\n  Log.debug(\"Environment\");\n  Log.debug(\"===================\");\n  if (CONFIG.debug) {\n    Util.execCommand(null, \"npm --version\", null);\n    Util.execCommand(null, \"node --version\", null);\n    Util.execCommand(null, \"git version\", null);\n  }\n  Log.debug(`Change Working directory to: ${CONFIG.tmpDirectory}`);\n  try {\n    Util.execCommand(null, [\"git config --global --add safe.directory /tmp\"]);\n  } catch {\n    try {\n      Util.execCommand(null, [\n        \"git config --global --add safe.directory \" + resolve(CONFIG.tmpDirectory)\n      ]);\n    } catch {\n      Log.error(\"Could not set tmp directoy as safe directory\");\n    }\n  }\n  process.chdir(CONFIG.tmpDirectory);\n  Log.debug(process.cwd());\n  try {\n    Log.info(\"\");\n    Log.info(\"Clone repository\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Copado.checkoutSrc(CONFIG.promotionBranch);\n    Copado.checkoutSrc(CONFIG.mainBranch);\n  } catch (ex) {\n    Log.error(\"Cloning failed:\" + ex.message);\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Merge branch\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Deploy.merge(CONFIG.promotionBranch, CONFIG.mainBranch);\n  } catch (ex) {\n    Log.error(\"Merge failed: \" + ex.message);\n    throw ex;\n  }\n  let commitSelectionArr;\n  try {\n    Log.info(\"\");\n    Log.info(\n      `Add selected components defined in ${CONFIG.fileSelectionSalesforceId} to metadata JSON`\n    );\n    Log.info(\"===================\");\n    Log.info(\"\");\n    commitSelectionArr = Copado.getJsonFile(\n      CONFIG.fileSelectionSalesforceId,\n      CONFIG.fileSelectionFileName,\n      \"Retrieving list of selected items\"\n    );\n    if (!Array.isArray(commitSelectionArr) || commitSelectionArr.length === 0) {\n      throw new Error(\n        \"Copado has not registered any files ready for deployment. Please check if you committed all files.\"\n      );\n    }\n  } catch (ex) {\n    Log.error(\"Getting Deploy-selection file failed:\" + ex.message);\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Preparing\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Util.provideMCDevTools();\n    Util.provideMCDevCredentials(CONFIG.credentials);\n  } catch (ex) {\n    Log.error(\"initializing failed: \" + ex.message);\n    throw ex;\n  }\n  let deployFolder;\n  try {\n    Log.info(\"\");\n    Log.info(\"Determine deploy folder\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    deployFolder = Deploy.getDeployFolder();\n  } catch (ex) {\n    Log.error(\"getDeployFolder failed: \" + ex.message);\n    throw ex;\n  }\n  let sourceBU;\n  let targetBU;\n  try {\n    Log.info(\"\");\n    Log.info(\"Create delta package\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    sourceBU = Util.getBuName(CONFIG.credentialNameSource, CONFIG.source_mid);\n    targetBU = Util.getBuName(CONFIG.credentialNameTarget, CONFIG.target_mid);\n  } catch (ex) {\n    Log.error(\"Getting Source / Target BU failed: \" + ex.message);\n    throw ex;\n  }\n  try {\n    Deploy.updateMarketLists(sourceBU, targetBU, CONFIG.envVariables);\n  } catch (ex) {\n    Log.error(\"Updateing Market List failed: \" + ex.message);\n    throw ex;\n  }\n  try {\n    if (await Deploy.createDeltaPackage(\n      deployFolder,\n      commitSelectionArr,\n      sourceBU.split(\"/\")[1]\n    )) {\n      Log.info(\"Deploy BUs\");\n      Log.info(\"===================\");\n      const deployResult = await Deploy.deployBU(targetBU);\n      commitSelectionArr = Deploy.replaceMarketValues(commitSelectionArr);\n      Deploy.replaceAssetKeys(targetBU, commitSelectionArr, deployResult);\n    } else {\n      throw new Error(\"No changes found. Nothing to deploy\");\n    }\n  } catch (ex) {\n    Log.error(\"Deploy failed: \" + ex.message);\n    Copado.uploadToolLogs();\n    throw ex;\n  }\n  let gitDiffArr;\n  let verificationText;\n  try {\n    gitDiffArr = await Deploy.retrieveAndCommit(targetBU, commitSelectionArr);\n  } catch (ex) {\n    verificationText = \"Failed deploy verification, check BU on SFMC to verify manually. Git not updated with the changes on target BU\";\n    Log.warn(verificationText + \": \" + ex.message);\n    gitDiffArr = [];\n  }\n  let success = false;\n  let i = 0;\n  do {\n    i++;\n    try {\n      Log.info(\"git-push changes\");\n      Log.info(\"===================\");\n      Util.push(CONFIG.mainBranch);\n      success = true;\n    } catch (ex) {\n      if (ex.message === `Error: Command failed: git push origin \"${CONFIG.mainBranch}\"`) {\n        Log.progress(\"Merging changes from parallel deployments\");\n        Util.execCommand(null, ['git fetch origin \"' + CONFIG.mainBranch + '\"'], null);\n        Util.execCommand(null, [\"git reset --hard origin/\" + CONFIG.mainBranch], null);\n        Util.execCommand(null, ['git merge \"' + CONFIG.promotionBranch + '\"'], null);\n      }\n    }\n  } while (!success && i <= 50);\n  Log.info(\"\");\n  Log.info(\"===================\");\n  Log.info(\"\");\n  Log.info(\"Deploy.js done\");\n  Log.result(\n    gitDiffArr,\n    `Deployed ${gitDiffArr.filter((item) => item.endsWith(\".json\")).length} items with ${gitDiffArr.length} files` + (verificationText ? ` (${verificationText})` : \"\")\n  );\n  Copado.uploadToolLogs();\n}\nvar Deploy = class {\n  static stashChanges() {\n    Util.execCommand(null, [`git stash`], null);\n  }\n  static async retrieveAndCommit(targetBU, commitSelectionArr) {\n    let gitAddArr;\n    let gitDiffArr = [];\n    try {\n      Log.info(\n        `Stashing changes made by mcdev.deploy() to avoid issues during branch checkout`\n      );\n      Deploy.stashChanges();\n      Log.info(\"Switch to source branch to add updates for target\");\n      Copado.checkoutSrc(CONFIG.promotionBranch);\n    } catch (ex) {\n      Log.error(\"Switching failed:\" + ex.message);\n      throw ex;\n    }\n    try {\n      Log.info(\"\");\n      Log.info(\"Retrieve components\");\n      Log.info(\"===================\");\n      Log.info(\"\");\n      gitAddArr = await Commit.retrieveCommitSelection(targetBU, commitSelectionArr);\n    } catch (ex) {\n      Log.error(\"Retrieving failed: \" + ex.message);\n      Copado.uploadToolLogs();\n      throw ex;\n    }\n    try {\n      Log.info(\"\");\n      Log.info(\"Add components in metadata JSON to Git history\");\n      Log.info(\"===================\");\n      Log.info(\"\");\n      Commit.addSelectedComponents(gitAddArr);\n    } catch (ex) {\n      Log.error(\"git add failed:\" + ex.message);\n      throw ex;\n    }\n    try {\n      Log.info(\"\");\n      Log.info(\"Commit\");\n      Log.info(\"===================\");\n      Log.info(\"\");\n      const commitMsgLines = Deploy.getCommitMessage(targetBU, commitSelectionArr);\n      gitDiffArr = Deploy.commit(commitMsgLines);\n    } catch (ex) {\n      Log.error(\"git commit failed:\" + ex.message);\n      throw ex;\n    }\n    try {\n      Log.info(\"Switch back to main branch to allow merging promotion branch into it\");\n      Copado.checkoutSrc(CONFIG.mainBranch);\n    } catch (ex) {\n      Log.error(\"Switching failed:\" + ex.message);\n      throw ex;\n    }\n    try {\n      Log.info(\"Merge promotion into main branch\");\n      Deploy.merge(CONFIG.promotionBranch, CONFIG.mainBranch);\n    } catch (ex) {\n      Log.error(\"Merge failed: \" + ex.message);\n      throw ex;\n    }\n    return gitDiffArr;\n  }\n  static commit(commitMsgLines) {\n    const gitDiffArr = execSync(\"git diff --staged --name-only\").toString().split(\"\\n\").map((item) => item.trim()).filter((item) => !!item);\n    Log.debug(\"Git diff ended with the result:\");\n    Log.debug(gitDiffArr);\n    if (Array.isArray(gitDiffArr) && gitDiffArr.length) {\n      if (!Array.isArray(commitMsgLines)) {\n        commitMsgLines = [CONFIG.commitMessage];\n      }\n      const commitMsgParam = commitMsgLines.map((line) => '-m \"' + line + '\"').join(\" \");\n      Util.execCommand(\n        \"Committing changes\",\n        [\"git commit -n \" + commitMsgParam],\n        \"Completed committing\"\n      );\n      Log.progress(\"Commit of target BU files completed\");\n    } else {\n      Log.error(\n        \"Nothing to commit as all selected components have the same content as already exists in Git.\",\n        \"Nothing to commit\"\n      );\n      throw new Error(\"Nothing to commit\");\n    }\n    return gitDiffArr;\n  }\n  static getCommitMessage(targetBU, commitSelectionArr) {\n    const userStoryNames = [\n      ...new Set(commitSelectionArr.map((item) => item.u).filter(Boolean))\n    ].sort();\n    const commitMsgLines = [\n      CONFIG.promotionName + \": \" + userStoryNames.join(\", \"),\n      `Updated BU \"${targetBU}\" (${CONFIG.target_mid})`\n    ];\n    return commitMsgLines;\n  }\n  static _convertCommitToDeltaPkgItems(commitSelectionArr, sourceBU) {\n    return commitSelectionArr.map(\n      (item) => ({\n        type: item.t.split(\"-\")[0],\n        name: item.n,\n        externalKey: JSON.parse(item.j).newKey || JSON.parse(item.j).key,\n        gitAction: \"add/update\",\n        _credential: CONFIG.credentialNameSource,\n        _businessUnit: sourceBU\n      })\n    );\n  }\n  static getDeployFolder() {\n    var _a;\n    if (!fs.existsSync(CONFIG.configFilePath)) {\n      throw new Error(\"Could not find config file \" + CONFIG.configFilePath);\n    }\n    const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, \"utf8\"));\n    const folder = (_a = config == null ? void 0 : config.directories) == null ? void 0 : _a.deploy;\n    if (!folder) {\n      throw new Error(\"Could not find config.directories.deploy in \" + CONFIG.configFilePath);\n    }\n    Log.debug(\"Deploy folder is: \" + folder);\n    return folder;\n  }\n  static updateMarketLists(sourceBU, targetBU, marketVariables) {\n    const deploySourceList = \"deployment-source\";\n    const deployTargetList = \"deployment-target\";\n    const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, \"utf8\"));\n    config.options.deployment.sourceTargetMapping = {};\n    config.options.deployment.sourceTargetMapping[deploySourceList] = deployTargetList;\n    config.markets = {};\n    if (CONFIG.deployNTimes) {\n      if (Object.keys(CONFIG.envVariables.sourceChildren).length !== 1) {\n        throw new Error(\n          'Expected exactly one source child BU when \"deployNTimes\" is active in pipeline but found ' + Object.keys(CONFIG.envVariables.sourceChildren).length\n        );\n      }\n      for (const childSfid in CONFIG.envVariables.sourceChildren) {\n        config.markets[childSfid] = CONFIG.envVariables.sourceChildren[childSfid];\n      }\n      for (const childSfid in CONFIG.envVariables.destinationChildren) {\n        config.markets[childSfid] = CONFIG.envVariables.destinationChildren[childSfid];\n      }\n    } else {\n      config.markets[\"source\"] = marketVariables.source;\n      config.markets[\"target\"] = marketVariables.destination;\n    }\n    config.marketList = {};\n    for (const listName of [deploySourceList, deployTargetList]) {\n      config.marketList[listName] = {};\n    }\n    if (CONFIG.deployNTimes) {\n      config.marketList[deploySourceList][sourceBU] = Object.keys(\n        CONFIG.envVariables.sourceChildren\n      )[0];\n      config.marketList[deployTargetList][targetBU] = Object.keys(\n        CONFIG.envVariables.destinationChildren\n      );\n    } else {\n      config.marketList[deploySourceList][sourceBU] = \"source\";\n      config.marketList[deployTargetList][targetBU] = \"target\";\n    }\n    Log.debug(\"config.options.deployment.sourceTargetMapping\");\n    Log.debug(config.options.deployment.sourceTargetMapping);\n    Log.debug(\"config.markets\");\n    Log.debug(config.markets);\n    Log.debug(\"config.marketList\");\n    Log.debug(JSON.stringify(config.marketList));\n    try {\n      fs.renameSync(CONFIG.configFilePath, CONFIG.configFilePath + \".BAK\");\n      Util.saveJsonFile(CONFIG.configFilePath, config, \"utf8\");\n    } catch (ex) {\n      Log.error(\"Updating updateMarketLists failed: \" + ex.message);\n      throw ex;\n    }\n  }\n  static async createDeltaPackage(deployFolder, commitSelectionArr, sourceBU) {\n    const mcdev = require(\"../tmp/node_modules/mcdev/lib\");\n    mcdev.setSkipInteraction(true);\n    const versionRange = null;\n    let deltaPkgItems = null;\n    if (Array.isArray(commitSelectionArr) && commitSelectionArr.length) {\n      deltaPkgItems = this._convertCommitToDeltaPkgItems(commitSelectionArr, sourceBU);\n      Log.info(`Found ${deltaPkgItems.length} changed components in commits`);\n      Log.debug(\"DeltaPkgItems: \");\n      Log.debug(deltaPkgItems);\n    } else {\n      Log.info(\"No changed components found in commits\");\n    }\n    const deltaPackageLog = await mcdev.createDeltaPkg({\n      range: versionRange,\n      diffArr: deltaPkgItems\n    });\n    Log.debug(\"deltaPackageLog: \" + JSON.stringify(deltaPackageLog));\n    if (!(deltaPackageLog == null ? void 0 : deltaPackageLog.length)) {\n      Log.error(\"No changes found for deployment\");\n      return false;\n    } else {\n      Log.debug(\"deltaPackageLog:\");\n      Log.debug(deltaPackageLog);\n    }\n    Log.debug(\"Completed creating delta package\");\n    if (fs.existsSync(CONFIG.deltaPackageLog)) {\n      Copado.attachLog(CONFIG.deltaPackageLog);\n    }\n    if (fs.existsSync(deployFolder)) {\n      const deltaPackageFiles = fs.readdirSync(deployFolder);\n      if (null != deltaPackageFiles) {\n        Log.debug(\"Found \" + deltaPackageFiles.length + \" files to deploy\");\n        if (0 < deltaPackageFiles.length) {\n          return true;\n        }\n      } else {\n        Log.debug(\"Could not find any files to deploy in folder \" + deployFolder);\n      }\n    } else {\n      Log.debug(\"Could not find deploy folder \" + deployFolder);\n    }\n    return false;\n  }\n  static _getConfigForToBranch(branch) {\n    let configBranch = branch;\n    if (branch.startsWith(\"release/\")) {\n      configBranch = \"release/*\";\n    } else if (branch.startsWith(\"hotfix/\")) {\n      configBranch = \"hotfix/*\";\n    }\n    Log.debug(\"Config branch for branch \" + branch + \" is \" + configBranch);\n    return configBranch;\n  }\n  static async deployBU(bu) {\n    const mcdev = require(\"../tmp/node_modules/mcdev/lib\");\n    mcdev.setSkipInteraction(true);\n    const deployResult = await mcdev.deploy(bu);\n    if (process.exitCode === 1) {\n      throw new Error(\n        \"Deployment of BU \" + bu + \" failed. Please check the SFMC DevTools logs for more details.\"\n      );\n    }\n    return deployResult;\n  }\n  static replaceAssetKeys(bu, commitSelectionArr, deployResult) {\n    const commitSelectionArrMap = [];\n    for (const i in commitSelectionArr) {\n      if (commitSelectionArr[i].t.split(\"-\")[0] === \"asset\") {\n        const suffix = \"-\" + CONFIG.target_mid;\n        const jObj = JSON.parse(commitSelectionArr[i].j);\n        const oldKey = jObj.newKey || jObj.key;\n        const newKey = CONFIG.source_mid === CONFIG.target_mid || oldKey.endsWith(suffix) ? oldKey : oldKey.slice(0, Math.max(0, 36 - suffix.length)) + suffix;\n        if (deployResult[bu].asset[newKey]) {\n          jObj.newKey = newKey;\n          commitSelectionArr[i].j = JSON.stringify(jObj);\n          commitSelectionArrMap.push(jObj);\n        } else {\n          throw new Error(\n            `New key for ${commitSelectionArr[i].n} does not match any valid keys.`\n          );\n        }\n      }\n    }\n    Util.saveJsonFile(`Copado Deploy changes-${CONFIG.target_mid}.json`, commitSelectionArr);\n    Copado.attachJson(`Copado Deploy changes-${CONFIG.target_mid}.json`, null, true);\n  }\n  static merge(promotionBranch, currentBranch) {\n    Util.execCommand(\n      `Merge ${promotionBranch} into ${currentBranch}`,\n      ['git merge \"' + promotionBranch + '\"'],\n      \"Completed merging commit\"\n    );\n  }\n  static replaceMarketValues(commitSelectionArr) {\n    Log.debug(\"replacing market values\");\n    const commitSelectionArrNew = [];\n    const replaceMapList = [];\n    if (CONFIG.deployNTimes) {\n      for (const sfid in CONFIG.envVariables.destinationChildren) {\n        const replaceMap = {};\n        const sourceSfid = Object.keys(CONFIG.envVariables.sourceChildren)[0];\n        for (const item in CONFIG.envVariables.sourceChildren[sourceSfid]) {\n          if (typeof CONFIG.envVariables.destinationChildren[sfid][item] !== \"undefined\") {\n            replaceMap[CONFIG.envVariables.sourceChildren[sourceSfid][item]] = CONFIG.envVariables.destinationChildren[sfid][item];\n          }\n        }\n        replaceMapList.push(replaceMap);\n      }\n    } else {\n      const replaceMap = {};\n      for (const item in CONFIG.envVariables.source) {\n        if (typeof CONFIG.envVariables.destination[item] !== \"undefined\") {\n          replaceMap[CONFIG.envVariables.source[item]] = CONFIG.envVariables.destination[item];\n        }\n      }\n      replaceMapList.push(replaceMap);\n    }\n    for (const replaceMap of replaceMapList) {\n      const commitSelectionArrClone = JSON.parse(JSON.stringify(commitSelectionArr));\n      for (const item of commitSelectionArrClone) {\n        for (const oldValue in replaceMap) {\n          item.n = item.n.replace(new RegExp(oldValue, \"g\"), replaceMap[oldValue]);\n          const jObj = JSON.parse(item.j);\n          jObj.newKey = (jObj.newKey || jObj.key).replace(\n            new RegExp(oldValue, \"g\"),\n            replaceMap[oldValue]\n          );\n          item.j = JSON.stringify(jObj);\n        }\n      }\n      commitSelectionArrNew.push(...commitSelectionArrClone);\n    }\n    return commitSelectionArrNew;\n  }\n};\nrun();",
          "copado__Timeout__c": 480,
          "copado__Type__c": "Custom",
          "copado__Version__c": "1",
          "copado__Worker_Size__c": "S"
        },
        {
          "attributes": {
            "type": "copado__Function__c",
            "url": "/services/data/v57.0/sobjects/copado__Function__c/a0k7Q000000nwH7QAI"
          },
          "Id": "a0k7Q000000nwH7QAI",
          "Name": "sfmc_Retrieve",
          "copado__API_Name__c": "sfmc_Retrieve",
          "copado__Image_Name__c": "0onz6fxsbyolcopmojdzlxa5vzgsts-sfmc-devtools:v1.0",
          "copado__Options__c": "[]",
          "copado__Parameters__c": "[{\"required\":true,\"name\":\"credentialNameSource\",\"defaultValue\":\"{$Source.Property.credential_name}\"},{\"required\":true,\"name\":\"credentials\",\"defaultValue\":\"{$Pipeline.Property.mc_credentials}\"},{\"required\":true,\"name\":\"git_json\",\"defaultValue\":\"{$Context.Repository.Credential}\"},{\"required\":true,\"name\":\"main_branch\",\"defaultValue\":\"{$Pipeline.Main_Branch__c}\"},{\"required\":true,\"name\":\"source_mid\",\"defaultValue\":\"{$Source.Property.mid}\"},{\"required\":true,\"name\":\"source_sfid\",\"defaultValue\":\"{$Source.Id}\"},{\"required\":false,\"name\":\"debug\",\"defaultValue\":\"{$Pipeline.Property.debug}\"},{\"required\":false,\"name\":\"installMcdevLocally\",\"defaultValue\":\"{$Pipeline.Property.installMcdevLocally}\"},{\"required\":false,\"name\":\"mcdev_version\",\"defaultValue\":\"{$Pipeline.Property.mc_devtools_version}\"}]",
          "copado__Script__c": "#!/usr/bin/env node\n#!/usr/bin/env node\n\n/*\n * mcdev-copado v1.3.0 (built 2022-12-05T15:06:56.955Z)\n * Function: Retrieve.fn.js\n * Dependenies: mcdev@>=4.1.12, Copado Deployer@20.1\n * Homepage: https://github.com/Accenture/sfmc-devtools-copado#readme\n * Support: https://github.com/Accenture/sfmc-devtools-copado/issues\n * Git-Repository: https://github.com/Accenture/sfmc-devtools-copado.git\n * Copyright (c) 2022 Accenture. MIT licensed\n*/\n\n\n\"use strict\";\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// types/mcdev-copado.d.js\nvar require_mcdev_copado_d = __commonJS({\n  \"types/mcdev-copado.d.js\"(exports, module2) {\n    module2.exports = {};\n  }\n});\n\n// common/Config.js\nvar require_Config = __commonJS({\n  \"common/Config.js\"(exports, module2) {\n    module2.exports = {};\n  }\n});\n\n// common/Log.js\nvar require_Log = __commonJS({\n  \"common/Log.js\"(exports, module2) {\n    \"use strict\";\n    var execSync = require(\"child_process\").execSync;\n    var CONFIG2 = require_Config();\n    var Log2 = class {\n      static debug(msg) {\n        if (CONFIG2.debug) {\n          console.log(\"DEBUG:\", msg);\n        }\n      }\n      static warn(msg) {\n        console.log(\"\\u26A0\", msg);\n      }\n      static info(msg) {\n        console.log(msg);\n      }\n      static error(error, msg = \"Error\") {\n        console.log(\"\\u274C\", error);\n        error = JSON.stringify(error);\n        msg = JSON.stringify(msg);\n        execSync(`copado --error-message ${error} --progress ${msg}`);\n      }\n      static result(json, msg = \"Result attached\") {\n        if (typeof json !== \"string\") {\n          json = JSON.stringify(json);\n        }\n        console.log(\"\\u2705\", json);\n        json = JSON.stringify(`${msg}: ${json}`);\n        msg = JSON.stringify(msg);\n        execSync(`copado --result-data ${json} --progress ${msg}`);\n      }\n      static progress(msg) {\n        msg = JSON.stringify(msg);\n        execSync(`copado --progress ${msg}`);\n      }\n    };\n    module2.exports = Log2;\n  }\n});\n\n// common/Util.js\nvar require_Util = __commonJS({\n  \"common/Util.js\"(exports, module2) {\n    \"use strict\";\n    var fs2 = require(\"fs\");\n    var execSync = require(\"child_process\").execSync;\n    var TYPE2 = require_mcdev_copado_d();\n    var CONFIG2 = require_Config();\n    var Log2 = require_Log();\n    var Util2 = class {\n      static saveJsonFile(localPath, jsObj, beautify) {\n        const jsonString = beautify ? JSON.stringify(jsObj, null, 4) : JSON.stringify(jsObj);\n        fs2.writeFileSync(localPath, jsonString, \"utf8\");\n      }\n      static push(destinationBranch) {\n        Util2.execCommand(\n          `Pushing updates to ${destinationBranch} branch`,\n          ['git push origin \"' + destinationBranch + '\"'],\n          \"Completed pushing branch\"\n        );\n      }\n      static execCommand(preMsg, command, postMsg) {\n        if (null != preMsg) {\n          Log2.progress(preMsg);\n        }\n        if (command && Array.isArray(command)) {\n          command = command.join(\" && \");\n        }\n        Log2.debug(\"\\u26A1 \" + command);\n        try {\n          execSync(command, { stdio: [0, 1, 2], stderr: \"inherit\" });\n        } catch (ex) {\n          Log2.info(ex.status + \": \" + ex.message);\n          throw new Error(ex);\n        }\n        if (null != postMsg) {\n          Log2.debug(\"\\u2714\\uFE0F  \" + postMsg);\n        }\n      }\n      static execCommandReturnStatus(preMsg, command, postMsg) {\n        if (null != preMsg) {\n          Log2.progress(preMsg);\n        }\n        if (command && Array.isArray(command)) {\n          command = command.join(\" && \");\n        }\n        Log2.debug(\"\\u26A1 \" + command);\n        let exitCode = null;\n        try {\n          execSync(command, { stdio: [0, 1, 2], stderr: \"inherit\" });\n          exitCode = 0;\n        } catch (ex) {\n          Log2.warn(\"\\u274C  \" + ex.status + \": \" + ex.message);\n          exitCode = ex.status;\n          return exitCode;\n        }\n        if (null != postMsg) {\n          Log2.progress(\"\\u2714\\uFE0F  \" + postMsg);\n        }\n        return exitCode;\n      }\n      static provideMCDevTools() {\n        if (fs2.existsSync(\"package.json\")) {\n          Log2.debug(\"package.json found, assuming npm was already initialized\");\n        } else {\n          Util2.execCommand(\"Initializing npm\", [\"npm init -y\"], \"Completed initializing NPM\");\n        }\n        let installer;\n        if (!CONFIG2.installMcdevLocally) {\n          Util2.execCommand(\n            `Initializing Accenture SFMC DevTools (packaged version)`,\n            [\n              `npm link mcdev --no-audit --no-fund --ignore-scripts --omit=dev --omit=peer --omit=optional`,\n              \"mcdev --version\"\n            ],\n            \"Completed installing Accenture SFMC DevTools\"\n          );\n          return;\n        } else if (CONFIG2.mcdevVersion.charAt(0) === \"#\") {\n          installer = `accenture/sfmc-devtools${CONFIG2.mcdevVersion}`;\n        } else if (!CONFIG2.mcdevVersion) {\n          Log2.error(\"Please specify mcdev_version in pipeline & environment settings\");\n          throw new Error(\"Please specify mcdev_version in pipeline & environment settings\");\n        } else {\n          installer = `mcdev@${CONFIG2.mcdevVersion}`;\n        }\n        Util2.execCommand(\n          `Initializing Accenture SFMC DevTools (${installer})`,\n          [`npm install ${installer}`, \"node ./node_modules/mcdev/lib/cli.js --version\"],\n          \"Completed installing Accenture SFMC DevTools\"\n        );\n      }\n      static provideMCDevCredentials(credentials) {\n        Log2.info(\"Provide authentication\");\n        Util2.saveJsonFile(\".mcdev-auth.json\", credentials, true);\n      }\n      static convertSourceProperties(properties) {\n        const response = {};\n        for (const item of properties) {\n          response[item.copado__API_Name__c] = item.copado__Value__c;\n        }\n        return response;\n      }\n      static convertEnvVariables(envVariables) {\n        Object.keys(envVariables).map((key) => {\n          if (key.endsWith(\"Children\")) {\n            envVariables[key] = Util2._convertEnvChildVars(envVariables[key]);\n          } else {\n            envVariables[key] = Util2._convertEnvVars(envVariables[key]);\n          }\n        });\n      }\n      static _convertEnvVars(envVarArr) {\n        if (!envVarArr) {\n          return envVarArr;\n        }\n        if (typeof envVarArr === \"string\") {\n          envVarArr = JSON.parse(envVarArr);\n        }\n        const response = {};\n        for (const item of envVarArr) {\n          response[item.name] = item.value;\n        }\n        return response;\n      }\n      static _convertEnvChildVars(envChildVarArr) {\n        if (!envChildVarArr) {\n          return envChildVarArr;\n        }\n        if (typeof envChildVarArr === \"string\") {\n          envChildVarArr = JSON.parse(envChildVarArr);\n        }\n        const response = {};\n        for (const item of envChildVarArr) {\n          response[item.id] = Util2._convertEnvVars(item.environmentVariables);\n        }\n        return response;\n      }\n      static getBuName(credName, mid) {\n        let credBuName;\n        if (!credName) {\n          throw new Error('System Property \"credentialName\" not set');\n        }\n        if (!mid) {\n          throw new Error('System Property \"mid\" not set');\n        }\n        if (!fs2.existsSync(CONFIG2.configFilePath)) {\n          throw new Error(\"Could not find config file \" + CONFIG2.configFilePath);\n        }\n        const config = JSON.parse(fs2.readFileSync(CONFIG2.configFilePath, \"utf8\"));\n        if (config.credentials[credName] && config.credentials[credName].businessUnits) {\n          const myBuNameArr = Object.keys(config.credentials[credName].businessUnits).filter(\n            (buName) => config.credentials[credName].businessUnits[buName] == mid\n          );\n          if (myBuNameArr.length === 1) {\n            Log2.debug(\"BU Name is: \" + credName + \"/\" + myBuNameArr[0]);\n            credBuName = credName + \"/\" + myBuNameArr[0];\n          } else {\n            throw new Error(`MID ${mid} not found for ${credName}`);\n          }\n        }\n        return credBuName;\n      }\n    };\n    module2.exports = Util2;\n  }\n});\n\n// common/Copado.js\nvar require_Copado = __commonJS({\n  \"common/Copado.js\"(exports, module2) {\n    \"use strict\";\n    var fs2 = require(\"fs\");\n    var exec = require(\"child_process\").exec;\n    var TYPE2 = require_mcdev_copado_d();\n    var Log2 = require_Log();\n    var Util2 = require_Util();\n    var Copado2 = class {\n      static mcdevInit(credentials, credentialName, url) {\n        Util2.execCommand(\n          `Initializing mcdev: ${credentialName}, ${credentials[credentialName].client_id}\", \"${credentials[credentialName].client_secret}\", \"${credentials[credentialName].auth_url}\", \"${url}\", ${credentials[credentialName].account_id}`,\n          [\n            `mcdev init --y.credentialName \"${credentialName}\" --y.client_id \"${credentials[credentialName].client_id}\" --y.client_secret \"${credentials[credentialName].client_secret}\" --y.auth_url \"${credentials[credentialName].auth_url}\" --y.gitRemoteUrl \"${url}\" --y.account_id ${credentials[credentialName].account_id} --y.downloadBUs \"false\" --y.gitPush \"true\"`\n          ],\n          \"Mcdev initialized!\"\n        );\n      }\n      static attachJson(localPath, parentSfid, async = false, preMsg) {\n        Copado2._attachFile(localPath, async, parentSfid, preMsg);\n      }\n      static async attachLog(localPath) {\n        Copado2._attachFile(localPath, true);\n      }\n      static _attachFile(localPath, async = false, parentSfid, preMsg, postMsg = \"Completed uploading file\") {\n        const command = `copado --uploadfile \"${localPath}\"` + (parentSfid ? ` --parentid \"${parentSfid}\"` : \"\");\n        if (async) {\n          Log2.debug(\"\\u26A1 \" + command);\n          try {\n            exec(command);\n          } catch (ex) {\n            Log2.info(ex.status + \": \" + ex.message);\n            throw new Error(ex);\n          }\n        } else {\n          if (!preMsg) {\n            preMsg = \"Uploading file \" + localPath;\n            if (parentSfid) {\n              preMsg += ` to ${parentSfid}`;\n            }\n          }\n          Util2.execCommand(preMsg, [command], postMsg);\n        }\n      }\n      static _downloadFile(fileSFID, preMsg) {\n        if (fileSFID) {\n          if (!preMsg) {\n            preMsg = `Download ${fileSFID}.`;\n          }\n          Util2.execCommand(preMsg, `copado --downloadfiles \"${fileSFID}\"`, \"Completed download\");\n        } else {\n          throw new Error(\"fileSalesforceId is not set\");\n        }\n      }\n      static getJsonFile(fileSFID, fileName, preMsg) {\n        Copado2._downloadFile(fileSFID, preMsg);\n        return JSON.parse(fs2.readFileSync(fileName, \"utf8\"));\n      }\n      static checkoutSrc(workingBranch, createBranch = false) {\n        Util2.execCommand(\n          `Switching to ${workingBranch} branch`,\n          [`copado-git-get ${createBranch ? \"--create \" : \"\"}\"${workingBranch}\"`],\n          \"Completed creating/checking out branch\"\n        );\n      }\n      static deleteBranch(featureBranch) {\n        Util2.execCommand(\n          `Deleting branch ${featureBranch} on server`,\n          [`git push origin --delete ${featureBranch}`],\n          \"Completed deleting server branch \" + featureBranch\n        );\n        Util2.execCommand(\n          `Deleting branch ${featureBranch} locally`,\n          [`git branch --delete --force ${featureBranch}`],\n          \"Completed deleting local branch \" + featureBranch\n        );\n      }\n      static async uploadToolLogs() {\n        Log2.debug(\"Getting mcdev logs\");\n        try {\n          const logsAttached = [];\n          for (const file of fs2.readdirSync(\"logs\")) {\n            Log2.debug(\"- \" + file);\n            logsAttached.push(Copado2.attachLog(\"logs/\" + file));\n          }\n          const response = await Promise.all(logsAttached);\n          Log2.debug(\"Attached mcdev logs\");\n          return response;\n        } catch (ex) {\n          Log2.debug(\"attaching mcdev logs failed:\" + ex.message);\n        }\n      }\n    };\n    module2.exports = Copado2;\n  }\n});\n\n// Retrieve.fn.js\nvar fs = require(\"fs\");\nvar resolve = require(\"path\").resolve;\nvar TYPE = require_mcdev_copado_d();\nvar CONFIG = require_Config();\nvar Log = require_Log();\nvar Util = require_Util();\nvar Copado = require_Copado();\nCONFIG.mcdevCopadoVersion = \"1.3.0\";\nCONFIG.credentialNameSource = process.env.credentialNameSource;\nCONFIG.credentialNameTarget = null;\nCONFIG.credentials = process.env.credentials;\nCONFIG.configFilePath = \".mcdevrc.json\";\nCONFIG.debug = process.env.debug === \"true\" ? true : false;\nCONFIG.installMcdevLocally = process.env.installMcdevLocally === \"true\" ? true : false;\nCONFIG.mainBranch = process.env.main_branch;\nCONFIG.mcdevVersion = process.env.mcdev_version;\nCONFIG.metadataFilePath = \"mcmetadata.json\";\nCONFIG.source_mid = process.env.source_mid;\nCONFIG.tmpDirectory = \"../tmp\";\nCONFIG.source_sfid = process.env.source_sfid;\nCONFIG.commitMessage = null;\nCONFIG.featureBranch = null;\nCONFIG.fileSelectionSalesforceId = null;\nCONFIG.fileSelectionFileName = null;\nCONFIG.recreateFeatureBranch = null;\nCONFIG.envVariables = {\n  source: null,\n  sourceChildren: null,\n  destination: null,\n  destinationChildren: null\n};\nCONFIG.deltaPackageLog = null;\nCONFIG.destinationBranch = null;\nCONFIG.fileUpdatedSelectionSfid = null;\nCONFIG.git_depth = null;\nCONFIG.merge_strategy = null;\nCONFIG.promotionBranch = null;\nCONFIG.promotionName = null;\nCONFIG.target_mid = null;\nasync function run() {\n  Log.info(\"Retrieve.js started\");\n  Log.debug(\"\");\n  Log.debug(\"Parameters\");\n  Log.debug(\"===================\");\n  try {\n    CONFIG.credentials = JSON.parse(CONFIG.credentials);\n  } catch (ex) {\n    Log.error(\"Could not parse credentials\");\n    throw ex;\n  }\n  Util.convertEnvVariables(CONFIG.envVariables);\n  Log.debug(CONFIG);\n  if (!CONFIG.credentials[CONFIG.credentialNameSource]) {\n    Log.error(`No credentials found for source (${CONFIG.credentialNameSource})`);\n    throw new Error(`No credentials`);\n  }\n  Log.debug(\"Credentials found for source BU\");\n  Log.debug(\"Environment\");\n  Log.debug(\"===================\");\n  if (CONFIG.debug) {\n    Util.execCommand(null, \"npm --version\", null);\n    Util.execCommand(null, \"node --version\", null);\n    Util.execCommand(null, \"git version\", null);\n  }\n  Log.debug(`Change Working directory to: ${CONFIG.tmpDirectory}`);\n  try {\n    Util.execCommand(null, [\"git config --global --add safe.directory /tmp\"]);\n  } catch {\n    try {\n      Util.execCommand(null, [\n        \"git config --global --add safe.directory \" + resolve(CONFIG.tmpDirectory)\n      ]);\n    } catch {\n      Log.error(\"Could not set tmp directoy as safe directory\");\n    }\n  }\n  process.chdir(CONFIG.tmpDirectory);\n  Log.debug(process.cwd());\n  try {\n    Log.info(\"\");\n    Log.info(\"Clone repository\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Copado.checkoutSrc(CONFIG.mainBranch);\n  } catch (ex) {\n    Log.error(\"Cloning failed:\" + ex.message);\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Preparing\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Util.provideMCDevTools();\n    Util.provideMCDevCredentials(CONFIG.credentials);\n  } catch (ex) {\n    Log.error(\"initializing failed: \" + ex.message);\n    throw ex;\n  }\n  let sourceBU;\n  let metadataJson;\n  try {\n    Log.info(\"\");\n    Log.info(\"Get source BU\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    sourceBU = Util.getBuName(CONFIG.credentialNameSource, CONFIG.source_mid);\n  } catch (ex) {\n    Log.error(\"Getting Source BU failed: \" + ex.message);\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.progress(\"Retrieving components\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    metadataJson = await Retrieve.retrieveChangelog(sourceBU);\n  } catch (ex) {\n    Log.error(\"Retrieving failed: \" + ex.message);\n    Copado.uploadToolLogs();\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Saving metadata JSON to disk\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Util.saveJsonFile(CONFIG.metadataFilePath, metadataJson);\n  } catch (ex) {\n    Log.error(\"Saving metadata JSON failed:\" + ex.message);\n    throw ex;\n  }\n  try {\n    Log.info(\"\");\n    Log.info(\"Attach JSON\");\n    Log.info(\"===================\");\n    Log.info(\"\");\n    Copado.attachJson(\n      CONFIG.metadataFilePath,\n      CONFIG.source_sfid,\n      false,\n      \"Loading items into Copado\"\n    );\n  } catch (ex) {\n    Log.error(\"Attaching JSON file failed:\" + ex.message);\n    throw ex;\n  }\n  Log.result(`Found ${metadataJson.length} items on server`, \"Refresh done\");\n  Log.info(\"\");\n  Log.info(\"===================\");\n  Log.info(\"\");\n  Log.info(\"Retrieve.js done\");\n  Copado.uploadToolLogs();\n}\nvar Retrieve = class {\n  static getRetrieveFolder() {\n    if (!fs.existsSync(CONFIG.configFilePath)) {\n      throw new Error(\"Could not find config file \" + CONFIG.configFilePath);\n    }\n    const config = JSON.parse(fs.readFileSync(CONFIG.configFilePath, \"utf8\"));\n    const directories = config[\"directories\"];\n    if (null == directories) {\n      throw new Error(\"Could not find directories in \" + CONFIG.configFilePath);\n    }\n    const folder = directories[\"retrieve\"];\n    if (null == folder) {\n      throw new Error(\"Could not find directories/retrieve in \" + CONFIG.configFilePath);\n    }\n    Log.debug(\"Retrieve folder is: \" + folder);\n    return folder;\n  }\n  static async retrieveChangelog(sourceBU) {\n    const mcdev = require(\"../tmp/node_modules/mcdev/lib\");\n    const Definition = require(\"../tmp/node_modules/mcdev/lib/MetadataTypeDefinitions\");\n    const MetadataType = require(\"../tmp/node_modules/mcdev/lib/MetadataTypeInfo\");\n    if (!CONFIG.debug) {\n      mcdev.setLoggingLevel({ silent: true });\n    }\n    mcdev.setSkipInteraction(true);\n    const customDefinition = {\n      automation: {\n        keyField: \"CustomerKey\",\n        nameField: \"Name\",\n        createdDateField: \"CreatedDate\",\n        createdNameField: \"CreatedBy\",\n        lastmodDateField: \"LastSaveDate\",\n        lastmodNameField: \"LastSavedBy\"\n      }\n    };\n    const retrieve = await mcdev.retrieve(sourceBU, [\"accountUser\"], null, true);\n    if (!retrieve) {\n      throw new Error(\"Could not retrieve User List\");\n    }\n    const userList = retrieve.accountUser;\n    for (const key of Object.keys(userList)) {\n      userList[userList[key].ID] = userList[key].Name;\n      delete userList[key];\n    }\n    const changelogList = await mcdev.retrieve(sourceBU, null, null, true);\n    const allMetadata = [];\n    Object.keys(changelogList).map((type) => {\n      if (changelogList[type]) {\n        const def = customDefinition[type] || Definition[type];\n        allMetadata.push(\n          ...Object.keys(changelogList[type]).map((key) => {\n            const item = changelogList[type][key];\n            const salesforceRegex = new RegExp(/(_Salesforce)(_[0-9])?$/gm);\n            if (MetadataType[type].isFiltered(item, true) || MetadataType[type].isFiltered(item, false)) {\n              return;\n            }\n            if (type === \"dataExtension\" && (this._getAttrValue(item, def.nameField).startsWith(\n              \"QueryStudioResults at \"\n            ) || salesforceRegex.test(this._getAttrValue(item, def.nameField)))) {\n              return;\n            }\n            const listEntry = {\n              n: this._getAttrValue(item, def.nameField),\n              k: this._getAttrValue(item, def.keyField),\n              p: this._getAttrValue(item, \"r__folder_Path\"),\n              t: this._getAttrValue(item, \"_subType\") ? type + \"-\" + this._getAttrValue(item, \"_subType\") : type,\n              cd: this._convertTimestamp(\n                this._getAttrValue(item, def.createdDateField)\n              ),\n              cb: this._getUserName(userList, item, def.createdNameField),\n              ld: this._convertTimestamp(\n                this._getAttrValue(item, def.lastmodDateField) !== \"0001-01-01T00:00:00\" ? this._getAttrValue(item, def.lastmodDateField) : this._getAttrValue(item, def.createdDateField)\n              ),\n              lb: this._getUserName(userList, item, def.lastmodNameField)\n            };\n            return listEntry;\n          })\n        );\n      }\n    });\n    return allMetadata.filter((item) => void 0 !== item);\n  }\n  static _convertTimestamp(iso8601dateTime) {\n    if (!iso8601dateTime || iso8601dateTime === \"0001-01-01T00:00:00\") {\n      return \"-\";\n    }\n    if (iso8601dateTime.split(\"-\").length === 3) {\n      iso8601dateTime += \"-06:00\";\n    }\n    return iso8601dateTime;\n  }\n  static _getUserName(userList, item, fieldname) {\n    return userList[this._getAttrValue(item, fieldname)] || this._getAttrValue(item, fieldname) || \"n/a\";\n  }\n  static _getAttrValue(obj, key) {\n    if (!key || !obj) {\n      return null;\n    }\n    if (key.includes(\".\")) {\n      const keys = key.split(\".\");\n      const first = keys.shift();\n      return this._getAttrValue(obj[first], keys.join(\".\"));\n    } else {\n      return obj[key];\n    }\n  }\n};\nrun();",
          "copado__Timeout__c": 30,
          "copado__Type__c": "Custom",
          "copado__Version__c": "1",
          "copado__Worker_Size__c": "S"
        }
      ],
      "ObjectType": "copado__Function__c"
    }
  ],
  "blobsByUID": {}
}